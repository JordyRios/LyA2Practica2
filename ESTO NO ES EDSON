package practicaVCI;

import java.util.ArrayList;
import java.util.Stack;

public class EstatutosMethods {

    public EstatutosMethods() {
    }

    public void handleKeywords(ArrayList<Token> tablaDeTokens, ArrayList<Token> vci, Stack<Integer> direcciones) {
        Stack<Token> estatutos = new Stack<>();
        Stack<Token> operadores = new Stack<>();

        for (int i = 0; i < tablaDeTokens.size(); i++) {
            Token token = tablaDeTokens.get(i);

            switch (token.getToken()) {
                case "IF":
                case "WHILE":
                    estatutos.push(token);
                    direcciones.push(i);
                    break;

                case "THEN":
                    while (!operadores.isEmpty()) {
                        operadores.pop();
                    }
                    direcciones.push(vci.size());
                    vci.add(new Token("FALSO")); // Generar token FALSO
                    vci.add(new Token("THEN"));  // Generar token THEN
                    break;

                case "ELSE":
                    estatutos.push(token);
                    int dir = direcciones.pop();
                    vci.get(dir).setApuntador(vci.size() + 2); // Almacenar valor del apuntador + 2 posiciones
                    vci.add(new Token("FALSO"));  // Generar token FALSO
                    direcciones.push(vci.size()); // Push (dir) de la dir del VCI en pila
                    vci.add(new Token("ELSE"));   // Generar token ELSE
                    break;

                case "END":
                    if (!estatutos.isEmpty()) {
                        Token last = estatutos.pop();
                        if (last.getToken().equals("IF")) {
                            if (i + 1 < tablaDeTokens.size() && tablaDeTokens.get(i + 1).getToken().equals("ELSE")) {
                                i++; // Si siguiente token es un ELSE, se ignora regla del END y pasa control al ELSE
                            } else {
                                int dirEnd = direcciones.pop();
                                vci.get(dirEnd).setApuntador(i);
                            }
                        } else if (last.getToken().equals("WHILE")) {
                            int dirEnd = direcciones.pop();
                            int dirVci = direcciones.pop();
                            vci.get(dirEnd).setApuntador(dirVci);
                            vci.add(new Token("END-WHILE")); // Genera token END-WHILE
                        }
                    }
                    break;

                case "DO":
                    while (!operadores.isEmpty()) {
                        operadores.pop();
                    }
                    direcciones.push(i);
                    break;

                case "REPEAT":
                    direcciones.push(i);
                    break;

                case "UNTIL":
                    Token tempToken = new Token("TEMP");
                    vci.add(tempToken);
                    int dirRepeat = direcciones.pop();
                    vci.get(dirRepeat).setApuntador(i);
                    vci.add(new Token("UNTIL")); // Genera token UNTIL
                    break;

                default:
                    VciMethods vciMethods = new VciMethods();
                    boolean itsVci = vciMethods.checkVci(token);
                    if (itsVci) {
                        vciMethods.moveToVci(token, vci);
                    }
                    break;
            }
        }
    }
}
-----------------------------------------------------
